#+TITLE: Keyboards, Modifier keys, Consoles, Terminal Emulators etc in UNIX systems

Feel I need this as a master document o tie together some other stuff which is currently spread into different files such as
 - [[file:Shell%20Scripting%20Magic.org][Some tips & Commands to make Shell Scripting always Pretty Sweet]]
 - [[file:my%20emacs%20and%20keybinding%20dilemma.org][The Emacs/Linux/Super Key epic keybinding Odyssey.org]]
 - [[file:Unix%20Systems%20Help.org][Help for all Unix Related Things]]
 - [[file:Z-Shell.org][Z-Shell]]
 - etc

The hierarchy of input:
* Terminals
** XTerm
*** Source Code
In file
: input.c 
#+BEGIN_SRC C
static Bool
TranslationsUseKeyword(Widget w, char **cache, const char *keyword, Bool onlyInsert)
#+END_SRC
* .Xdefaults/.XResources file and xrdb
https://wiki.archlinux.org/index.php/Xdefaults
https://github.com/sunaku/home/blob/master/.Xdefaults
More on this
http://www.klauser.com/lxug/ch12.pdf
** The X Toolkit
This is what is being manipulated by the settings in a .Xresouces type file and stored in the database with .xrdb

*** The Translation Table
All X Toolkit widgets contain a translation table.
The translation table specifies the translation from an event sequence to the actions that are then invoked.
Each translation is separated from one another by a newline.
**** Event Sequence
Comma separated list of X Event descriptions.
A single description has 3 parts:
1. The X Event Type
2. A prefix consisting of the X Modifier bits
3. An event specific suffix
**** Action Sequence
Each action sequence call is the name of an action procedure and a parenthesized list of parameters.

**** replace/augment/override
Something like
: #override
or
: #replace
specifies whether to replace, augment or override the existing table.
**** Translation Table Syntax
http://lesstif.sourceforge.net/doc/super-ux/g1ae03e/part1/appb.html
The syntax of a translation table is :
#+BEGIN_VERSE
translationTable	= [ directive ] { production }
directive	= ( "#replace" | "#override" | "#augment" ) "\\n"
production	= lhs ":" rhs "\\n"
lhe	= ( event | keyseq ) ( "," (event | keyseq) )
keyseq	= """ keychar (keychar) """
keychar	= [ "^" | "$" | "\\" ] <ISO Latin 1 character>
event	= [modifier_list] "<"event_type">" [ "(" count["+"] ")" ] {detail}
modifier_list	= ( ["!"] [":"] {modifier} ) | "None"
modifier	= ["~"] modifier_name
count	= (" 1 " | "2" | "3" | "4" |... )
modifier_name	= "@" <keysym> | <see ModifierNames table below>
event_type	= <see Event Types table below>
detail	= <event specific details>
rhs	= { name "(" [params] ")" }
name	= namechar { namechar }
namechar	= { "a"-"z" | "A"-"Z" | "0"-"9" | "_" | "-" }
params	= string { "," string }
string	= quoted_string | unquoted_string
quoted_string	= """ {<Latin 1 character> | escape_char) ["\\\\" ] """
escape_char	= "\\""
unquoted_string	= t<Latin 1 character except space, tab, ",", "\\n", ")">)
#+END_VERSE
**** Specifically related to modifier keys
Modifier Names

The modifier field is used to specify standard X keyboard and button modifier mask bits. Modifiersare legal on event types KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify, LeaveNotify, and their abbreviations. An error is generated when a translation table that contains modifiers for any other events is parsed.

 - If the modifier list has no entries and is not "None", it means "don't care" on all modifiers.
 - If an exclamation point (!) is specified at the beginning of the modifier list, it means that the listed modifiers must be in the correct state and no other modifiers can be asserted.
 - If any modifiers are specified and an exclamation point (!) is not specified, it means that the listed modifiers must be in the correct state and "don't care" about any other modifiers.
 - If a modifier is preceded by a tilde (~), it means that that modifier must not be asserted.
 - If "None" is specified, it means no modifiers can be asserted.
 - If a colon (:) is specified at the beginning of the modifier list, it directs the Intrinsics to apply any standard modifiers in the event to map the event keycode into a KeySym. The default standard modifiers are Shift and Lock, with the interpretation as defined in X Window System Protocol, Section 5. The resulting KeySym must exactly match the specified KeySym, and the nonstandard modifiers in the event must match the modifier list. For example, ":<Key>a" is distinct from ":<Key>A", and ":Shift<Key>A" is distinct from ":<Key>A".
 - If both an exclamation point (!) and a colon (:) are specified at the beginning of the modifier list, it means that the listed modifiers must be in the correct state and that no other modifiers except the standard modifiers can be asserted. Any standard modifiers in the event are applied as for colon (:) above.
 - If a colon (:) is not specified, no standard modifiers are applied. Then, for example, "<Key>A" and "<Key>a" are equivalent.
 - In key sequences, a circumflex (^) is an abbreviation for the Control modifier, a dollar sign ($) is an abbreviation for Meta, and a backslash (\) can be used to quote any character, in particular a double quote ("), a circumflex (^), a dollar sign ($), and another backslash (\). 

Briefly:
|---------------------------------+-------------+----------------|
| Description                     | Mod List    | event          |
|---------------------------------+-------------+----------------|
| No Modifiers:                   | None        | <event> detail |
| Any Modifiers:                  |             | <event> detail |
| Only these Modifiers:           | ! mod1 mod2 | <event> detail |
| These modifiers and any others: | mod1 mod2   | <event> detail |
|---------------------------------+-------------+----------------|
The use of "None" for a modifier list is identical to the use of an exclamation point with no modifiers.
**** Modifier List
|----------+--------------+--------------------------|
| Modifier | Abbreviation | Meaning                  |
|----------+--------------+--------------------------|
| Ctrl     | c            | Control modifier bit     |
| Shift    | s            | Shift modifier bit       |
| Lock     | l            | Lock modifier bit        |
| Meta     | m            | Meta key modifier        |
| Hyper    | h            | Hyper key modifier       |
| Super    | su           | Super key modifier       |
| Alt      | a            | Alt key modifier         |
| Mod1     |              | Mod1 modifier bit        |
| Mod2     |              | Mod2 modifier bit        |
| Mod3     |              | Mod3 modifier bit        |
| Mod4     |              | Mod4 modifier bit        |
| Mod5     |              | Mod5 modifier bit        |
| Button1  |              | Button1 modifier bit     |
| Button2  |              | Button2 modifier bit     |
| Button3  |              | Button3 modifier bit     |
| Button4  |              | Button4 modifier bit     |
| Button5  |              | Button5 modifier bit     |
| None     |              | No modifiers             |
| Any      |              | Any modifier combination |
|----------+--------------+--------------------------|
A key modifier is any modifier bit one of whose corresponding KeyCodes contains the corresponding left or right KeySym. For example, "m" or "Meta" means any modifier bit mapping to a KeyCode whose KeySym list contains XK_Meta_L or XK_Meta_R. Note that this interpretation is for each display, not global or even for each application context. The Control, Shift, and Lock modifier names refer explicitly to the corresponding modifier bits; there is no additional interpretation of KeySyms for these modifiers.

Because it is possible to associate arbitrary KeySyms with modifiers, the set of key modifiers is extensible. The "@" <keysym> syntax means any modifier bit whose corresponding KeyCode contains the specified KeySym name.

A modifier_list/KeySym combination in a translation matches a modifiers/KeyCode combination in an event in the following ways:

1. If a colon (:) is used, the Intrinsics call the display's XtKeyProc with the KeyCode and modifiers. To match, (modifiers & ~modifiers_return) must equal modifier_list, and keysym_return must equal the given KeySym.
2. If (:) is not used, the Intrinsics mask off all don't-care bits from the modifiers. This value must be equal to modifier_list. Then, for each possible combination of don't-care modifiers in the modifier list, the Intrinsics call the display's XtKeyProc with the KeyCode and that combination ORed with the cared-about modifier bits from the event. Keysym_return must match the KeySym in the translation.
**** 
*** What is the X Toolkit syntax
The basic syntax of an Xresources file is as follows:
: name.Class.resource: value
**** Things that may stop things working
Avoid blank spaces at the beginning and end of lines in the .Xresources file.
**** What are comments?
It says 
: ! This is a comment
but it doesn seem to be
: /* This is i think */
**** Modifier key semantics/Syntax
** See what has been already set in xrdb
: xrdb -query -all
** Get properties of a running process
Probably most importantly its name/class
: xprop
** Setting/Changing things Manually
Put Settings you want in
: .XResources
Then either completely reload the database with
: xrdb .Xresources
or merge changes in to old settings with
: xrdb -merge .Xresources
and then start xterm
** Check raw output of keys
Run command
: cat -v
and then look at output on screen...
** Setting Resources with the -xrm Option
The -xrm command-line option, which is supported by all X Window System clients written with the X Toolkit, can be useful in specifying from the command line any specification that you would otherwise put into a resources file. e.g 
: xterm -xrm 'xterm*Foreground: blue' &

** How -name Affects Resources
The following command sets the xterm instance name to bigxterm:
: xterm -name bigxterm &
When this command is run, the client uses any resources specified for bigxterm rather than for xterm.
#+BEGIN_VERSE
XTerm*Font:          8x13
smallxterm*Font:     6x10
smallxterm*Geometry: 80x10
bigxterm*Font:       9x15
bigxterm*Geometry:   80x55
#+END_VERSE
** Getting the list of Resources that apply only to one particular xclient
Use the command appres
: appres XTerm
Or to get a named instance
: appres XTerm bigxterm
* xModmap/xkb/xserver
I think same stuff
** OS X
If i do 
: xkbcomp $DISPLAY something.xkb
It has no keycode or keysym info

If I use the xkb configuration file that i use to log into uni from this kayboard then it seems to have pretty much the same effect on the local xterm/xerver....

** Is a perfect xkb setup more or less keyboard dependet than anything else?
As said before:

If I use the xkb configuration file that i use to log into uni from this kayboard then it seems to have pretty much the same effect on the local xterm/xerver....
* stty/putty
* terminfo/termcap - tcap/tput
Good info here:
http://docstore.mik.ua/orelly/unix/upt/ch05_07.htm
http://docstore.mik.ua/orelly/unix/upt/ch05_10.htm
http://www.tldp.org/HOWTO/Text-Terminal-HOWTO-16.html
** Basic Stuff
#+BEGIN_VERSE
termcap and terminfo , by contrast, tend to control visual attributes of the terminal.
...
A program that wants to make use of the terminal capability database selects an entry according to the value of the TERM environment variable ( 6.1 ) . This variable is typically set when a user logs in. A second variable, either TERMCAP ( 5.4 ) or TERMINFO , may also be set, if it is desirable to point to a terminal description that is not in the standard location.
...
The terminal names to which TERM can legitimately be set can be determined by searching through /etc/termcap or by listing the names of files in the /usr/lib/terminfo directory hierarchy.
#+END_VERSE
It seems emacs shell typically sets itself to 
: TERM=DUMB
** terminfo
Is a text based database of info according to terminal emulators the value of which is stored in $TERM
: /lib/terminfo/x/xterm
** termcap
** tcap & tput
http://docstore.mik.ua/orelly/unix/upt/ch41_10.htm
#+BEGIN_VERSE
For each terminal in the database, there is a list of terminal capabilities ( 41.11 ) . The tput program (standard on any system with terminfo ) lets you print out the value of any individual capability. The tcap program does the same for systems using termcap . ( tcap was originally named tc . We renamed it to avoid conflicts with tc , the ditroff interpreter program for Tektronix 4015 terminals.) This makes it possible to use terminal capabilities such as those for standout mode in shell programs.
#+END_VERSE
** To read a terminfo file according to your TERM value
Call
: infocmp
and to check if your terminal is in the database call for example:
: locate vt100

From the output i can see that the arrow keys are mapped to the following
cursor up = CUU
cursor down = CUD
cursor back = CUB
cursor forward = CUF
: kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,

** Output of infocmp on both konsole/kde and terminal/gnome
** Konsole/KDE
#+BEGIN_VERSE
#       Reconstructed via infocmp from file: /lib/terminfo/x/xterm
xterm|X11 terminal emulator,
        am, bce, km, mc5i, mir, msgr, npc, xenl,
        colors#8, cols#80, it#8, lines#24, pairs#64,
        acsc=``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
        clear=\E[H\E[2J, cnorm=\E[?12l\E[?25h, cr=^M,
        csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
        cud=\E[%p1%dB, cud1=^J, cuf=\E[%p1%dC, cuf1=\E[C,
        cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
        cvvis=\E[?12;25h, dch=\E[%p1%dP, dch1=\E[P, dl=\E[%p1%dM,
        dl1=\E[M, ech=\E[%p1%dX, ed=\E[J, el=\E[K, el1=\E[1K,
        flash=\E[?5h$<100/>\E[?5l, home=\E[H, hpa=\E[%i%p1%dG,
        ht=^I, hts=\EH, ich=\E[%p1%d@, il=\E[%p1%dL, il1=\E[L,
        ind=^J, indn=\E[%p1%dS, invis=\E[8m,
        is2=\E[!p\E[?3;4l\E[4l\E>, kDC=\E[3;2~, kEND=\E[1;2F,
        kHOM=\E[1;2H, kIC=\E[2;2~, kLFT=\E[1;2D, kNXT=\E[6;2~,
        kPRV=\E[5;2~, kRIT=\E[1;2C, kb2=\EOE, kbs=\177, kcbt=\E[Z,
        kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
        kdch1=\E[3~, kend=\EOF, kent=\EOM, kf1=\EOP, kf10=\E[21~,
        kf11=\E[23~, kf12=\E[24~, kf13=\E[1;2P, kf14=\E[1;2Q,
        kf15=\E[1;2R, kf16=\E[1;2S, kf17=\E[15;2~, kf18=\E[17;2~,
        kf19=\E[18;2~, kf2=\EOQ, kf20=\E[19;2~, kf21=\E[20;2~,
        kf22=\E[21;2~, kf23=\E[23;2~, kf24=\E[24;2~,
        kf25=\E[1;5P, kf26=\E[1;5Q, kf27=\E[1;5R, kf28=\E[1;5S,
        kf29=\E[15;5~, kf3=\EOR, kf30=\E[17;5~, kf31=\E[18;5~,
        kf32=\E[19;5~, kf33=\E[20;5~, kf34=\E[21;5~,
        kf35=\E[23;5~, kf36=\E[24;5~, kf37=\E[1;6P, kf38=\E[1;6Q,
        kf39=\E[1;6R, kf4=\EOS, kf40=\E[1;6S, kf41=\E[15;6~,
        kf42=\E[17;6~, kf43=\E[18;6~, kf44=\E[19;6~,
        kf45=\E[20;6~, kf46=\E[21;6~, kf47=\E[23;6~,
        kf48=\E[24;6~, kf49=\E[1;3P, kf5=\E[15~, kf50=\E[1;3Q,
        kf51=\E[1;3R, kf52=\E[1;3S, kf53=\E[15;3~, kf54=\E[17;3~,
        kf55=\E[18;3~, kf56=\E[19;3~, kf57=\E[20;3~,
        kf58=\E[21;3~, kf59=\E[23;3~, kf6=\E[17~, kf60=\E[24;3~,
        kf61=\E[1;4P, kf62=\E[1;4Q, kf63=\E[1;4R, kf7=\E[18~,
        kf8=\E[19~, kf9=\E[20~, khome=\EOH, kich1=\E[2~,
        kind=\E[1;2B, kmous=\E[M, knp=\E[6~, kpp=\E[5~,
        kri=\E[1;2A, mc0=\E[i, mc4=\E[4i, mc5=\E[5i, meml=\El,
        memu=\Em, op=\E[39;49m, rc=\E8, rev=\E[7m, ri=\EM,
        rin=\E[%p1%dT, rmacs=\E(B, rmam=\E[?7l, rmcup=\E[?1049l,
        rmir=\E[4l, rmkx=\E[?1l\E>, rmso=\E[27m, rmul=\E[24m,
        rs1=\Ec, rs2=\E[!p\E[?3;4l\E[4l\E>, sc=\E7,
        setab=\E[4%p1%dm, setaf=\E[3%p1%dm,
        setb=\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        setf=\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        sgr=%?%p9%t\E(0%e\E(B%;\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,
        sgr0=\E(B\E[m, smacs=\E(0, smam=\E[?7h, smcup=\E[?1049h,
        smir=\E[4h, smkx=\E[?1h\E=, smso=\E[7m, smul=\E[4m,
        tbc=\E[3g, u6=\E[%i%d;%dR, u7=\E[6n, u8=\E[?1;2c, u9=\E[c,
        vpa=\E[%i%p1%dd,z
#+END_VERSE
** Gnome/Terminal
#+BEGIN_VERSE
#	Reconstructed via infocmp from file: /lib/terminfo/x/xterm
xterm|X11 terminal emulator,
	am, bce, km, mc5i, mir, msgr, npc, xenl,
	colors#8, cols#80, it#8, lines#24, pairs#64,
	acsc=``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
	bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
	clear=\E[H\E[2J, cnorm=\E[?12l\E[?25h, cr=^M,
	csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
	cud=\E[%p1%dB, cud1=^J, cuf=\E[%p1%dC, cuf1=\E[C,
	cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
	cvvis=\E[?12;25h, dch=\E[%p1%dP, dch1=\E[P, dl=\E[%p1%dM,
	dl1=\E[M, ech=\E[%p1%dX, ed=\E[J, el=\E[K, el1=\E[1K,
	flash=\E[?5h$<100/>\E[?5l, home=\E[H, hpa=\E[%i%p1%dG,
	ht=^I, hts=\EH, ich=\E[%p1%d@, il=\E[%p1%dL, il1=\E[L,
	ind=^J, indn=\E[%p1%dS, invis=\E[8m,
	is2=\E[!p\E[?3;4l\E[4l\E>, kDC=\E[3;2~, kEND=\E[1;2F,
	kHOM=\E[1;2H, kIC=\E[2;2~, kLFT=\E[1;2D, kNXT=\E[6;2~,
	kPRV=\E[5;2~, kRIT=\E[1;2C, kb2=\EOE, kbs=\177, kcbt=\E[Z,
	kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
	kdch1=\E[3~, kend=\EOF, kent=\EOM, kf1=\EOP, kf10=\E[21~,
	kf11=\E[23~, kf12=\E[24~, kf13=\EO2P, kf14=\EO2Q,
	kf15=\EO2R, kf16=\EO2S, kf17=\E[15;2~, kf18=\E[17;2~,
	kf19=\E[18;2~, kf2=\EOQ, kf20=\E[19;2~, kf21=\E[20;2~,
	kf22=\E[21;2~, kf23=\E[23;2~, kf24=\E[24;2~, kf25=\EO5P,
	kf26=\EO5Q, kf27=\EO5R, kf28=\EO5S, kf29=\E[15;5~,
	kf3=\EOR, kf30=\E[17;5~, kf31=\E[18;5~, kf32=\E[19;5~,
	kf33=\E[20;5~, kf34=\E[21;5~, kf35=\E[23;5~,
	kf36=\E[24;5~, kf37=\EO6P, kf38=\EO6Q, kf39=\EO6R,
	kf4=\EOS, kf40=\EO6S, kf41=\E[15;6~, kf42=\E[17;6~,
	kf43=\E[18;6~, kf44=\E[19;6~, kf45=\E[20;6~,
	kf46=\E[21;6~, kf47=\E[23;6~, kf48=\E[24;6~, kf49=\EO3P,
	kf5=\E[15~, kf50=\EO3Q, kf51=\EO3R, kf52=\EO3S,
	kf53=\E[15;3~, kf54=\E[17;3~, kf55=\E[18;3~,
	kf56=\E[19;3~, kf57=\E[20;3~, kf58=\E[21;3~,
	kf59=\E[23;3~, kf6=\E[17~, kf60=\E[24;3~, kf61=\EO4P,
	kf62=\EO4Q, kf63=\EO4R, kf7=\E[18~, kf8=\E[19~, kf9=\E[20~,
	khome=\EOH, kich1=\E[2~, kmous=\E[M, knp=\E[6~, kpp=\E[5~,
	mc0=\E[i, mc4=\E[4i, mc5=\E[5i, meml=\El, memu=\Em,
	op=\E[39;49m, rc=\E8, rev=\E[7m, ri=\EM, rin=\E[%p1%dT,
	rmacs=\E(B, rmam=\E[?7l, rmcup=\E[?1049l, rmir=\E[4l,
	rmkx=\E[?1l\E>, rmso=\E[27m, rmul=\E[24m, rs1=\Ec,
	rs2=\E[!p\E[?3;4l\E[4l\E>, sc=\E7, setab=\E[4%p1%dm,
	setaf=\E[3%p1%dm,
	setb=\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
	setf=\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
	sgr=\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\E(0%e\E(B%;,
	sgr0=\E[m\E(B, smacs=\E(0, smam=\E[?7h, smcup=\E[?1049h,
	smir=\E[4h, smkx=\E[?1h\E=, smso=\E[7m, smul=\E[4m,
	tbc=\E[3g, u6=\E[%i%d;%dR, u7=\E[6n, u8=\E[?1;2c, u9=\E[c,
	vpa=\E[%i%p1%dd,
#+END_VERSE
** Differences between kde and gnome
*** kde
: kf13=\E[1;2P, kf14=\E[1;2Q, kf15=\E[1;2R, kf16=\E[1;2S,
: kf25=\E[1;5P, kf26=\E[1;5Q, kf27=\E[1;5R, kf28=\E[1;5S, 
: kf37=\E[1;6P, kf38=\E[1;6Q, kf39=\E[1;6R, kf4=\EOS, kf40=\E[1;6S,
: kf49=\E[1;3P,
: kf50=\E[1;3Q, kf51=\E[1;3R, kf52=\E[1;3S,
: kf61=\E[1;4P, kf62=\E[1;4Q, kf63=\E[1;4R, 
: kind=\E[1;2B, kri=\E[1;2A, 
: sgr=%?%p9%t\E(0%e\E(B%;\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,
: sgr0=\E(B\E[m,
*** gnome
: kf13=\EO2P, kf14=\EO2Q, kf15=\EO2R, kf16=\EO2S, 
: kf25=\EO5P, kf26=\EO5Q, kf27=\EO5R, kf28=\EO5S,
: kf37=\EO6P, kf38=\EO6Q, kf39=\EO6R, kf4=\EOS, kf40=\EO6S,
: kf49=\EO3P,
: kf50=\EO3Q, kf51=\EO3R, kf52=\EO3S,
: kf61=\EO4P, kf62=\EO4Q, kf63=\EO4R, 
: sgr=\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\E(0%e\E(B%;,
: sgr0=\E[m\E(B,
* Escape Sequences and Modifier Keys
This is source code from TMux
#+BEGIN_SRC C
	{ KEYC_RIGHT,	"\033[1;_C" },
	{ KEYC_LEFT,	"\033[1;_D" },
#+END_SRC
Now if the right key was pressed with Modifier 1 then the keycode would be
: \033[1;1C
and if pressed with Modifier 3 it would be
: \033[1;3C
if pressed with nothing it gives
: \033[C
** Generating Control-x etc from other keys
Control characters have ascii code equivalents.
This binds Super z to Control X (18), Control U (15)
: ! Super<Key>z:  string(0x18) string(0x15)\n\
* showkeys/dumpkeys/loadkeys
https://wiki.archlinux.org/index.php/Extra_Keyboard_Keys_in_Console
https://lists.gnu.org/archive/html/screen-users/2009-12/msg00144.html
* Readline - Bash and Z-Shell
* Screen/TMux
** And Bindings
You cant bind to arbitrary strings or escape sequences - only certain keys....
http://unix.stackexchange.com/questions/1636/how-do-i-bind-the-tmux-prefix-to-a-super
https://plus.google.com/110389149377588379226/posts/Nrtw5HFV1ov
** Tmux
*** Looking for key bindings in the source file
: "/Users/Hal/code/tmux/trunk/xterm-keys.c"
also 
: "/Users/Hal/code/tmux/trunk/tmux.h"

Look at this hardcoded shit - does this match our setup?
#+BEGIN_VERSE
/* Key modifier bits. */
#define KEYC_ESCAPE 0x2000
#define KEYC_CTRL 0x4000
#define KEYC_SHIFT 0x8000
#define KEYC_PREFIX 0x10000
#+END_VERSE
* If your terminal starts printing gibberish 
...prob because you read a non-ascii file and an escape sequence reset something then you should be able to reset things with
: tput init

* Overriding the escape key sequence generated by a particular key for a particular TERM type
Not sure where this goes....
If TERM=xterm-color and key is Home
: set-option -g terminal-overrides "xterm-color:khome=\033[1~"

* A good portable, consistent setup
One that has
 - Emacs
 - Mac Style bindings and use of command/super and Alt keys
 - A console with similar bindings

** xkb to bind keys to keysms and thus to bind to
: AltL/AltR & SuperL/SuperR
** Xresources to remap those keys to particular escape sequences in
:  xterm*VT100.translations:	#override \n\
** Z-Shell to bind these escape sequences to commands
Possibly using some xterm builtin features also...
** Tmux or Screen to give back the tab/split screen style features of a modern terminal

* Sources of info

** General Overview
http://vigna.dsi.unimi.it/bsdel/bsdel/x58.html
https://wiki.archlinux.org/index.php/Extra_Keyboard_Keys

** How a terminal basically works as intercepting stdin and stdout
http://sqizit.bartletts.id.au/2011/02/14/pseudo-terminals-in-python/
** xterm and escape sequences
http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
** infocmp and tic to redefine key sequences
http://stackoverflow.com/a/7975835/935470
