* Passenger
To restart passenger do
: touch tmp/restart.txt

* Bundler
** See local configuration options
: bundle config --local
** Get rid of gem installed by bundler
You have to get rid of all ones not required by the Gemfile
: bundle clean
: bundle clean --force 
will wipe even system gems

Otherwise you are supposed to do 
: bundle exec gem uninstall whatever
but this doesnt seem to work

* Rake
Show all tasks
: rake -T
or 
: rake -D


* Routing
** member vs collection
http://stackoverflow.com/questions/3028653/difference-between-collection-route-and-member-route-in-ruby-on-rails
                URL                 Helper                      Description
----------------------------------------------------------------------------------------------------------------------------------
member          /photos/1/preview   preview_photo_path(photo)   Acts on a specific resource so required id (preview specific photo)
collection      /photos/search      search_photos_url           Acts on collection of resources(display all photos)


* Diagnostics
inspect?
: @object.inspect
** Rails
*** Print a message from a controller/view
#+BEGIN_SRC ruby
render :json => 'This is the string'
#+END_SRC ruby
*** Print a debug message to the log
: logger.(debug|info|warn|error|fatal)
e.g.
: logger.debug "Person attributes hash: #{@person.attributes.inspect}"
 Calling it as =Rails.logger= is also valid

*** Using the =ruby-debug= gem
**** Setup/installation
See this blog
http://chrisadams.me.uk/2009/04/28/how-to-set-up-a-debugger-with-mod_railspassenger/

Actually that might be outdated - the whole thing took ages but below instructions should be good for Rails 3 and Ruby 1.9

***** Installing the Gem
# Problems with Ruby 1.9. I couldnt do it in Bundler (didnt try =sudo bundler= though)had to do this:
# : sudo gem install ruby-debug19
put 
: gem 'debugger'
in your Gemfile
***** Other Configuration to be done once per app
****** Whack this in config/environments/development.rb
#+BEGIN_SRC ruby
  if File.exists?(File.join(Rails.root,'tmp', 'debug.txt'))
    Debugger.wait_connection = true
    Debugger.start_remote
    File.delete(File.join(Rails.root,'tmp', 'debug.txt'))
  end
#+END_SRC
can specify port and host if you like
#+BEGIN_SRC ruby
  remote_host = '127.0.0.1' 
  remote_port = 7000 
  if File.exists?(File.join(Rails.root,'tmp', 'debug.txt'))
    Debugger.wait_connection = true
    Debugger.start_remote(remote_host, remote_port)
    File.delete(File.join(Rails.root,'tmp', 'debug.txt'))
  end
#+END_SRC
****** Create a rake restart task
Heres what i have in a =lib/tasks/rails_debug.rake= file
#+BEGIN_SRC ruby
    desc "Restarts passenger if in debug mode"
    task :restart do
      system("touch tmp/restart.txt")
      system("touch tmp/debug.txt") if ENV["DEBUG"] == 'true'
    end
#+END_SRC
****** Create an rdebug.rc file
 - either in home directory or current directory
 - This may have been crucial - not sure
At any rate heres what i have in my ./rdebug.rc file
#+BEGIN_VERSE
set autolist
set autoeval
set autoreload
#+END_VERSE
***** Configuration to be done whenever you want to start the debugger
****** Call restart of passenger via rake task with DEBUG env variable set to true
: bundle exec rake restart DEBUG=true
****** THEN - VERY IMPORTANT - you must load a NEW page to get server to work
any page it doesnt matter
****** Open a remote debug session with
: bundle exec rdebug -c
or if port and host specified earlier
: bundle exec rdebug -c -p 7000 -h 127.0.0.1

*** Checking for the eistance of a =params= key/value
: if params[:country_list].present?
* Commenting out Stuff in a Rails web template
Comments out both HTML and Ruby logic
#+BEGIN_SRC web
<%# if false %>
  ...old bit here
<% end %>
#+END_SRC web


* Gem Commands
** Check which gems a gem depends on (i.e. it needs)
gem dependency  rails

** ALSO check which gems depend on this gem (i.e. which need it)
gem dependency  -R rails

** Install a gem
sudo gem install -r zzzzzz

** Install a gem with version
** Adding a source to the gem package source list
gem  sources -a http://gems.github.com
** Uninstalling a gem and all dependencies
*** Shell Script - doesnt seem to recursively delete dependencies
Modified from:
for gem in `gem list --no-version`; do
  gem uninstall -aIx $gem
done

for gem in `gem dependency rails -v=3.2.1`; do
  gem uninstall -aIx $gem
done
*** Ruby Script from GitHub
https://github.com/mattdipasquale/gem_uninstall_r

** Searching for all version of rails gems on remote server
gem search -ra "rails" | egrep "^rails "

** Install a particular gem version - DOES THIS HAVE PROBLEMS?
sudo gem install -r rails -v=2.3.14
** Update the gem executable/rubygems
# New way
sudo gem update --system
# OLD WAY, for historical purposes 
sudo gem install rubygems-update --no-rdoc --no-ri
sudo update_rubygems

** Info on whre gems are installed etc
gem env


* Modules and loading/accessing their inards
** See loaded modules
=Module.included_modules=

For more:
http://www.ruby-doc.org/core-1.9.3/Module.htm

** Getting at an included module from
use =const_get= \\
 - ActiveSupport::Deprecation is a submodule
=ActiveSupport.const_get(:Deprecation).methods=

** Defining a module vs acccessing it
To define a module the first time we need to decalre the full module bit
#+BEGIN_SRC ruby
module LRD
  module FormHelper
    def labeled_input(object_name, method, options = {})
      input = text_field(object_name, method, options)
      label = label(object_name, method, options)
      content_tag(:div, (label+input), { :class =&gt; 'labeled_input' }
    end
  end
end
#+END_SRC ruby

Whereas to access it you just need something like:
#+END_SRC ruby
module LRD::FormBuilder
  # ActionPack's metaprogramming would have done this for us, if FormHelper#labeled_input 
  # had been defined  at load.   Instead we define it ourselves here.
  def labeled_input(method, options = {})
    @template.labeled_input(@object_name, method, objectify_options(options))
  end
end
#+END_SRC ruby


* Introspection - from the command line
** Check an objects methods minus inhereited stuff
obj.methods - Object.methods
** Look for specific methods
#+BEGIN_SRC ruby
=obj.methods.grep /to_/=
#+END_SRC ruby
or like above
#+BEGIN_SRC ruby
(UserProfile.find(3).knowtypes.methods - Object.methods).grep /create/ 
#+END_SRC ruby

Could even do some clever stuff like look for only methods that are not defined on parent:
#+BEGIN_SRC ruby
(obj_1.methods - obj_1.parent.methods).grep /create/ 
#+END_SRC ruby
or...
#+BEGIN_SRC ruby
#+END_SRC ruby
** Instance & Class Variables
obj.instance_variables
obj.class_variables

** Check which environment the rails console is being run in
: Rails.env
=> "development"


* Rails
** Console
*** Start the console in a particuar environment
: rails console development
or, allegedly:
: RAILS_ENV=test rails console
which should prob be:
: Rails.env=test rails console
*** Check which environment the rails console is being run in
: Rails.env
=> "development"
 - Dont seem to be able to change this properly by setting 
: Rails.env="production"
on the console command line

** Sprockets
 - =app/assets/stylesheets/application.css/= and =app/assets/javascripts/application.js/=
*** Comments
 - anything which is preceded with an = sign is included
 - otherwise its commented out
 - e.g. in the following
#+BEGIN_SRC css
/*
 *= require_self
 *= require foundation_and_overrides
 *= require_tree .
 * require jquery.ui.autocomplete
 */
#+END_SRC
the line 
:  * require jquery.ui.autocomplete
is "commented out". while
:  *= require_tree .
is not.


* Ruby Meta/Magic Stuff
** You can call methods based on strings with the send method
: object.send("add_#{@type_of_fruit}", d)
Heres a more involved example
#+BEGIN_SRC ruby
      	["backgrounds","knowtypes","interests","languages","cities","countries"].each do |t|
          if params["user_profile_#{t}"].present? 
            params["user_profile_#{t}"].each do |d|
              @user_profile.send("add_#{t.singularize}", d)
            end
          end
      	end
#+END_SRC
*** If locally defined method (same class) then do like this
same for Rails associations
#+BEGIN_SRC ruby
class UserProfileInterest < ActiveRecord::Base
  def bat_kill()
    send("bat_karate")
  end
  def bat_karate()
  end
end
#+END_SRC

See here also [[*Rails%20converting%20strings%20to%20symbols%20etc][Rails converting strings to symbols etc]]

** Operating system commands
Strings enclosed with backquotes or =%x{}= are be considered by Ruby as operating system commands. Just try:
: puts (`calc`)
: puts ("Current directory content is: #{%x/dir/}")


* Heroku
** Transferring a PostGres Database to and from heroku
http://www.ryandaigle.com/a/pgtransfer-is-the-new-taps
First install pg transfer
: heroku plugins:install https://github.com/ddollar/heroku-pg-transfer
*** Yeah i dont know Heres what I had to do
First put the database on a publically accessible url
 - in this case inside the =public_html= directory on my Net Virtue server
   - I had to make the enclosing =Hunome= directory and the =dev2prod.sql= file both readable and executable by the world
then i could run 
: heroku pgbackups:restore DATABASE 'http://halhenke.net/Hunome/dev_2_prod.sql' --confirm hunome-dev
and this worked - needed =--confirm hunome-dev= to 'force' this change

Sort of like this:
https://devcenter.heroku.com/articles/heroku-postgres-import-export#import

* Rails converting strings to symbols etc
This module does it:
: ActiveSupport::CoreExtensions::String::Inflections
e.g.
: 'Book Author Title'.parameterize.underscore.to_sym
 - note - =.to_sym= is a Ruby string method
** String to Class
: "Object".constantize # => Object
Apparently for Ruby you use
: Module.const_get
but this doesnt handle nesting

* Requiring code
We require files - not modules or namespaces
i.e.
=require(''active_record/deprecation)=
Unlike say elisp where we require a tag that is provided in a loadpath by a =provide= statement


* How does Rake work
Call rake in a directory it will automatically call the Rakefile

** Example of hurricane app
In this case it then requires these files:
#+BEGIN_SRC ruby
require 'config/boot'
require 'rake'
require 'rake/testtask'
require 'rdoc/task'
require 'tasks/rails'
#+END_SRC ruby
This is where we get the deprecation warnings
 - config/boot checks whether rails is running i think

then this task throws an error if RAILS_ENV isnt defined....
#+BEGIN_SRC ruby
task :touch_file => :environment do                                                          
  if ENV.has_key?('RAILS_ENV')                                                               
    RAILS_ENV = ENV['RAILS_ENV']                                                             
  else                                                                                       
    puts 'FATAL rake delayed_job:touchfile: RAILS_ENV not set.'                              
    exit 1                                                                                   
  end                                                                                        
  # 'Hurricane::TouchFileJob' is defined in config/initializers.                             
  puts "mynbcs (rails):RAILS_ENV=#{RAILS_ENV}: Queuing delayed job to touch file."           
  Delayed::Job.enqueue(Hurricane::TouchFileJob.new)                                          
end 
#+END_SRC ruby
otherwise it
 - prints "mynbcs (rails):RAILS_ENV=#{RAILS_ENV}: Queuing delayed job to touch file."   
 - and using the Delayed plugin
 - it puts a Hurricane::TouchFileJob class into a queue...



* Converting vendor/plugins to Rails 3 and/or gems
This is pretty in depth:
http://bibwild.wordpress.com/2012/04/25/converting-a-more-complex-rails-2-3-style-plugin-to-non-deprecated-under-rails-3-2/

Basically a few ways to do this:
** Just move it to the =/lib= directory
 - If theres just some logic - i.e. a Ruby script - this is the best approach
 - if theres something that has to be done at the beginning add some code to =config/initializers= directory
** Rebuild the plugin as a gem
 - not as hard as it might otherwise be given that we can use =Bundle gem= to provide the structure of a gem
 - still could be pretty bad
 - have to move stuff around
   - init code
   - rake tasks
** Use bundler to just include the repository/code
 - Not 100% sure this works but it could be the easiest
 - Just dont have the version resolution of a gem
   - ...which we dont have anyway with a plugin
 - Make up a fake version number - should be fine
** Use Rails::Engine inheritance
 - Generate a fake gemspec and whack it in the plugin root directory
 - 

* Is it possible to tell which gems an app is *actually* using?
 - in short - no
http://stackoverflow.com/questions/9793360/figuring-out-which-gems-rails-app-does-not-use
 - could load each gem and grep for method usage
 - also grep for requires
*BUT*
 - ruby can dynamically generate methods, eval a string etc.
 - Makes it prety much a manual process unless your test coverage is awesome...

** rough algorithm
*** load gem in ruby environment
 - inspect 
   - i.e. gemName.methods.collect {}
 - grep the app for any use of the term
 - log the result
*OR*
*** grep the gem source
 - get all "def xxxxx"

Yeah this seems stupid - why parse stuff



* Code Snippets
** Overriding Existing Module/Class Definitions

The following was an attempt to override deprecation messages being generated:
#+BEGIN_SRC ruby
module ActiveSupport
    module Deprecation
        class << self
            def warn(message = nil, callstack = caller)
                puts "poo"
                #behavior.call(deprecation_message(callstack, message), callstack) if behavior && !silenced?
            end
        end
        module ClassMethods
            def deprecated_method_warning(method_name, message=nil)
                puts "blah"
            end
        end
    end
end
#+END_SRC ruby

didnt work because ActiveSupport::Dependency.load_paths was not being called

Instead load paths was being called from 
=Rails::Initializer.do |config|=
and so we had to overload this:
#+BEGIN_SRC ruby
module Rails
    class Configuration
        # Deprecated, use autoload_paths.
        def load_paths
            # $stderr.puts("config.load_paths is deprecated and removed in Rails 3, please use autoload_paths instead")
            puts "whoops 1"
            autoload_paths
        end
        
        # Deprecated, use autoload_paths=.
        def load_paths=(paths)
            # $#stderr.puts("config.load_paths= is deprecated and removed in Rails 3, please use autoload_paths= instead")
            puts "whoops 2"
            self.autoload_paths = paths
        end
    end
end
#+END_SRC ruby

** Rails Controller Stuff
*** redirect output to the index method from the same controller
#+BEGIN_SRC ruby
    redirect_to ({:action => "index"}) and return
#+END_SRC ruby
*** call the =set_user_profile= method every time before the create method
#+BEGIN_SRC ruby
  before_filter :set_user_profile, :only =>[:create]
#+END_SRC ruby
**  Rails Active Record stuff
*** Assigning via _id or not
Both these are viable ways to do this and might be equivalent:
#+BEGIN_SRC ruby
@user_profile_knowtype.user_profile_id = @user_profile.id
#+END_SRC ruby
#+BEGIN_SRC ruby
@user_profile_knowtype.user_profile = @user_profile
#+END_SRC ruby


* Weird Errors
** Gem install brings in lots of different stuff inexplicably - UNSOLVED
running:
#+BEGIN_SRC bash
sudo gem install rails -v=2.3.14
sudo gem install rake -v=0.9.0
#+END_SRC bash
rake 0.9.2.2 was suddenly installed on philemon
along with Rails 3.2.1




* Specific Rails errors and solutions
If you get this:
: User(#70180561615400) expected, got ActiveSupport::HashWithIndifferentAccess(#70180531877120)
you may need
: accepts_nested_attributes_for :user
in your =UserProfile= declaration.
and in your form, make sure you have
#+BEGIN_SRC web
      <%= f.fields_for :user do |user| %>
#+END_SRC web
and not:
#+BEGIN_SRC web
      <%= f.fields_for @user_profile.user do |user| %>
#+END_SRC web
also may need =attr_accessible :user_attributes=


* From Hunome - Rails Tips & Explanations
** Namespaces in Routes and forms
?
** Forms
 - We are creating an HTML form that will update/create/edit a specific instance of a Rais model
 - So we have to specify fields for different model attributes we wish to edit.
  
   We have 3 basic ways to build form helpers:
   1. =form_tag= - completely manual form construction
      - takes two args: path and options
      - can form a complete form with the help of these others
	- =label_tag=
	- =text_field_tag=
	- =submit_tag=
   2. something like =<% text_field(model, model_property) %>= which takes two args
      - first is a model instance that is being edited
      - second is an attribute of the model (doesnt have to be attribute though - just property type pair of methods)
   3. =form_for(:model_instance)=
      - yields a form builder
      - methods called on form builder to build the specific form
      - effectively a shorthand for method
   4. =fields_for()= is same as 3 except does not create outer HTML form tags
      - therefore can be used to add form fields for other models in the same form 


* How forms in Rails work
 - You call forms_for on a model *instance* i.e. on an *object - not a class*
 - If its blank Rails will then generate empty fields you can add stuff too
 - If not Rails will add existing info to the fields and you can edit it
 - After this Rails will store all this in =params[:yourobjectname]=
   - This is effectively a series of string key value pairs (HTML cannot do anything else) but Rails will format in such a way that it will read it as a hash/array/dictionary.
** sub_objects
 - These can also be edited in a form
 - Rails will pass them to the post method with the suffix attributes e.g. =params[:user][:user_profile_attributes]=
 - check out the name of this input field
#+BEGIN_SRC web
       <input class="faux-tag-checkbox inline" type="checkbox" name="user[user_profile_attributes][user_profile_languages_attributes][]" value="<%= lang.id %>" <%= @user_profile.id.present? ? (@user_profile.has_language?(lang.id) ? "checked=\"true\"" : "") : "" %> />
#+END_SRC
 - the name determines what the key will be in the post form - if you have a [] at the end of the name then the values will be placed in an array
 - If you have =accepts_nested_attributes_for user_profile= in your =user= model *and* =user_profile= =belongs_to= =user= then it should work
   - you may have to write a =user_profile_attributes=(attributes)= method in =user= yourself
** More on different methods of building Forms
 - We are creating an HTML form that will update/create/edit a specific instance of a Rais model
 - So we have to specify fields for different model attributes we wish to edit.
  
   We have 3 basic ways to build form helpers:
   1. =form_tag= - completely manual form construction
      - takes two args: path and options
      - can form a complete form with the help of these others
	- =label_tag=
	- =text_field_tag=
	- =submit_tag=
   2. something like =<% text_field(model, model_property) %>= which takes two args
      - first is a model instance that is being edited
      - second is an attribute of the model (doesnt have to be attribute though - just property type pair of methods)
   3. =form_for(:model_instance)=
      - yields a form builder
      - methods called on form builder to build the specific form
      - effectively a shorthand for method
   4. =fields_for()= is same as 3 except does not create outer HTML form tags
      - therefore can be used to add form fields for other models in the same form 




* Compiling stuff for Production Mode
: bundle exec rake assets:precompile
: git add public/assets
: git commit -m "vendor compiled assets"
** To put on heroku
If not on =master= branch
: git push heroku yourbranch:master --force


* TODO PROBLEMS
** How to log *anything* from configuration file
i.e. from development.rb or Hunome::Application.configure
** DONE How to get remote debugger to work for me
Why doesnt start_remote/start_server seem to get called?
My =./.rdebugrc= file was mispelled as =./.redbug.rc=
