#+TITLE: My Ideal Coding Environment

Inspired by frustrations/temptations towards choosing Sublime Text over Emacs


* Pros of Emacs
** Open Source
** Run in terminal and graphical
** Everything is a buffer
Means we can run emacs commands, customisations, introspection etc in pretty much every place - such as the minibuffer - we can edit it like a normal emacs buffer - because it is. Contrast that to vim.
** Lots of stuff is run in e-lisp and not hardcoded in C which means we can re-script it
customisability
** Docstrings and Self-Documenting nature
Its not too hard to find info on a function, module or variable by using 
: describe function
: describe-variable
or info-mode
** Extensively customisable
** Eval/Debug/Run elisp in emacs
You can eval stuff in buffer that will
* Cons of Emacs
** Antiquated names, default settings
** Takes a long time to customize
** Frequently Buggy
** Lots of stuff is run in e-lisp and not hardcoded in C which means it is slow
And gets slower as we add more and more elisp customisation
customisability
** Sometimes slow
** functional language makes it hard to find available commands
I have a list - what the fuck can i do with it? 
How do i find the command?
** No proper namespacing
All commands and variables more or les live in the same global space and a lot of diffferent 'modes" run side by side. POtential for weird interactions
** Is there a better metaphor than "everything is a buffer"
** Semi-closed development process
*** Not on github
*** Hard to get involved and contribute
** No real tabs
* Pros of Sublime Text
** Works reasonably well "out of box"
** Can be customised
** "Hot-Pluggable" Extensions
** Single developer responsible for fixing most grievous bugs
** All keybindings/settings per plugin/user/env in a single JSON file
Great balance of modularity and centralization of settings

** Python Libraries 
 - not Sublime specific but can be pulled in and used to do...anything?
 - API limited though
* Cons of Sublime Text
** Closed Source
** Limited API?
** Python is kind of annoying

** Mouse needed to switch between windows?
** Too much OS integration in File/Sys IO?
Uses OS windows etc to select files.
Not as cool as using a buffer...
** Limited API  -What /cant/ be done?
** Console kind of sucks?
* What I want to be able to do in Sublime Text


* What I want - No bullshit, no legacy, From the Beginning.....
** Governing ideas
*** We only have a limited ammount of mental real estate - should avoid too much context switching
*** A consistent interface with other programs
** Ideas
*** Extensibility
*** Self-Documenting
*** More than just a Text Editor
 - More than just the vim philosophy of editing text
 - Able to adapt to different environments and usages that may not have been anticipated
**** Things that are more important than quickly editing text
***** Finding files
***** Quickly switching between different parts of a project and viewing code from different locations but semantically related at the same time
*** Fundamentally build on a few good, composable ideas
 - e.g. something /like/ "everything is  a buffer" 
** Features
*** Reasonably Fast
*** Reasonably Good Looking
*** Ability to interface well with command line/shell/OS
*** Deeply integrated with a good language
*** Namespaces
* Ideas to fix improve Emacs
** Hotpluggable Emacs with fast/static code
*** Solves the problem of Emacs getting too slow for some new features
**** If we wish to change something in to C - to statically code it we need to recompile
**** But If we had a way to translate from tried and trusted elisp code to an intermediary "R-Python" type language that did not need complete re-compilation of the interpreter. Could dynamically be loaded - perhaps like C++

** Add Tabs
*** Implementation
From what I have seen of the source this would basically involve treating some frames as "master/root frames" and others as "leaf frames"
 - Hopefully there is a way to do this which would be as non-interfering as possible with other C Code and not interfere at all with existing elisp code - unless one wished to.
*** More Details?
 - Default would be that every frame is a master frame as before
 - Could change a parameter/flag though to set this to different behaviour
* My Current Problem/Solution - Stringing together Emacs/XTerm/Tmux
Xterm + Tmux is basically a way to get around the problem of being stuck with a terminal-emulator such as 
1. Terminator
2. Gnome Terminal
which does not allow one to bind Super keys etc to 
 - arbitrary internal commands
   - beginning of line
 - or to escape sequences that we can the bind in z-shell
** Key bindings - Shouldnt Be This Fucking Hard
*** The Journey from Key Press to ACTION
1. Press key
2. Is interpreted by xServer via xkb into KeySym
3. KeySym is broken down by Terminal/Terminal Emulator into byte sequence
   1. Byte Sequence is interpreted by Shell Readilne and either bound to commands or executed as code
   2. Emacs or whatever deals with the key sym
*** The xkb binding procedure
1. So in "xkb_keycodes" section xkb takes a number (ASCII?) 
2. Generates a keycode to label that number - can be anything
   1. <LALT> = 23;
3. In "xkb_symbols" mode associates a keysym with that Keycode - again can be anything but can be different keysyms in different "Groups/States"
   1. key <LALT> {         [           Alt_L,          Meta_L ] };
4. Bind keycodes/keysyms to Modifiers - if a keycode has been bound to a keysym and is placed in a modifier map then both keycode and keysym are thus associated
   1. modifier_map Mod1 { <LALT> };

*** The problems with my emacs/xterm/tmux thing
**** Its getting pretty fucking convoluted
**** XTerm may not be capable of displaying some things/fonts well
**** I dont want to have to learn another set of key combinations - context switching
**** I want to bind some things only in tmux mode
e.g.
1. Super-t makes a new window
2. Super } switches to a new window

*** The main problem seems to be tmux 
while xterm can bind escape sequences pretty well to arbitrary key presses tmux cant bind actions to some of them for some reason...

*** The problem with binding from xterm to z-shell/tmux
Xterm translations takes key combinations including modifiers and 
turns them into string outputs including escape sequences

Z-shell bind-key and tmux sem to only take key inputs to bind from
This is OK in the case of the Function keys but for example i cant get something like this to work 
: ! Super<Key>z:    string("^X^U")\n\
This just produces the string on the right whereas
: Control X Control U
is actually a bit modified key...sequence thing....

For more on this see here 
http://unix.stackexchange.com/questions/31498/is-it-possible-to-send-a-control-sequence-to-a-terminal-emulator-using-the-keybo
#+BEGIN_VERSE
VT100s responded to character sequences sent to them as output. So echo'ing characters works because the terminal sees it as output. Typing characters is input; the terminal will respond only if the characters are echoed by the receiving computer. Your typical shell doesn't echo ESC, it interprets ESC as the prefix for some interactive input command. Run cat and type ESC Z RETURN and you'll see the usual VT100 response.
#+END_VERSE
*** Solved!... (mostly)
**** Generating Control-x etc from other keys
Control characters have ascii code equivalents.
This binds Super z to Control X (18), Control U (15)
: ! Super<Key>z:  string(0x18) string(0x15)\n\
*** New Problem...TMux "kills" non-standard xterm escape sequences before z-shell can grab them
**** Solutions?
1. Some solved by adding line to tmux.config
2. Apparently can get around rest by compiling own terminfo file with escape sequences defined
3. Or perhaps we can bind 
: Super-L/Super-R
to one of the other Function keys and having z-shell/bindkey bind command to that?

Kinda sucks....
* Writing my own terminal Emulator?
Basically something to intercept stdin and sstdout and rebind keys as i wish....
Would take keysyms from xkb and generate escape sequences for tmux or whatever.
** Would i do it in Emacs?
** Do it in Python?
